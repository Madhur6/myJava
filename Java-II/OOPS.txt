----------------------------------------‚≠ê‚≠ê ‚ú® INDEX ‚ú® ‚≠ê‚≠ê----------------------------------------

üí° CHAPTER I   : Pillars of OOPSüèõÔ∏è

üí° CHAPTER II  : 

----------------------------------------‚≠ê‚≠ê ‚ú® INDEX ‚ú® ‚≠ê‚≠ê----------------------------------------
				                      
									  << LET'S START LEARNING üòä >>


----------------------------------------‚≠ê‚≠ê CHAPTER I ‚≠ê‚≠ê----------------------------------------
#1 Pillars of OOPSüèõÔ∏è


‚≠ê ENCAPSULATION: Process of wrapping data(variables) & methods into a single unit(class)

‚≠ê INHERITANCE  : Process by which a child(subClass) acquires properties & behaviour of a parent(superClass)

‚≠ê ABSTRACTION  : Process of hiding complex implementation details & exposing only essential features

‚≠ê POLYMORPHISM : Ability of different objects to be treated as instances of the same parent type

_______________________________________________________________________________________

üí°: ‚≠ê ENCAPSULATION ‚≠ê

	- Giving controlled-access to the internal state of an object.
    
    - It is achieved using:
        - Access modifiers (```private`, `protected`, `public````)
        - Getter & Setter methods

    ‚úîÔ∏è Pros
        - Enhances security
        - Enables Access-Control
        - Protects data integrity
        - Promotes organized code structure
        - Simplifies maintenance & updates

    üê• Ex. Secure Digital Bagpack üëú


_______________________________________________________________________________________

üí°: ‚≠ê INHERITANCE ‚≠ê

	- Allos a subClass to *extend* the properties & behaviours of a superClass.

    ‚úîÔ∏è Pros
        - Code Reusability
        - Reduced duplication
        - Common logic remains centralized
        - SubClasses can add specialized behaviour

    ‚ùå Cons
        - Super & Sub Class can be tightly-coupled

    üê• Ex. GrandFather ‚Üí Father ‚Üí Child

  
    ‚úîÔ∏è ‚≠ê Types of Inheritance ‚≠ê
        
        - 1). Single-Level, [Base-Class ---------> Derived-Class]
                             parent                 child


        - 2). Multi-Level,  [Base-Class ---------> Derived-Class ---------> Derived-Class]
                               shape                rectangle             Equilateral-Triangle
                      
              
        - 3). Hierarchial,  [Base-Class ---------> Derived-Class]
                               shape                rectanlge
                                |
                                |
                                v
                            [Derived-Class]
                              circle

       
        - 4). Hybrid,       [Combination of above 2 or more types]
                            [Achieved in JAVA using Interfaces]

        - 5). Multiple,     [Doesn't Exists in Java as inheritence]
                            [Achieved in JAVA using Interfaces]




_______________________________________________________________________________________

üí°: ‚≠ê ABSTRACTION ‚≠ê

    - Hiding complex implementation details from users.

	- Abstraction focuses on *what an object does*, Not *How it does it*
    

    - It is achieved using:
        - `abstract` classes
        - `interfaces`        (100% abstraction)

    ‚úîÔ∏è Pros
        - Improves Simplicity
        - Enhances flexibility
        - Better UX
        - Encourages focus on essential features
        - Reduces implementation complexity

    ‚ö†Ô∏è Notes:
        - Abstract-Classes *cannot be instantiated*
        
        - They may contain:
            - Abstract methods
            - Concrete (implemented) methods
        
        - SubClasses must implement abstract methods unless they are abstract themselves üëΩ



_______________________________________________________________________________________

Q. Difference BW Abstract Class & Interface‚ùî


- **Abstract-Class**                           | - **Interface**
                                               |
  - Methods can use ANY access-modifiers       |   - Methods are:
                                               |        ‚Ä¢ public by default (abstract | default | static)
                                               |        ‚Ä¢ private allowed (Java 9+ | Not for abstract methods)
                                               |
                                               |
  - Can have both abstract & concrete method.  |   - Methods can be:
                                               |        ‚Ä¢ abstract (public | NOT static)
                                               |        ‚Ä¢ default  (public | NOT static)
                                               |        ‚Ä¢ private  (helper methods, Java 9+)
                                               |        ‚Ä¢ static   (public | private(Java 9+) | can't override)
                                               |
                                               |
  - Can have instance variables.               |   - Variables are ALWAYS: public static final (constants)
                                               |
  - A class can extend ONLY ONE abstract class |   - A class can implement MULTIPLE interfaces
    [Single Inheritence]                       |     [Multiple inheritence supported]
                                               |          
                                               |
  - Can have `Constructors`                    |   - Cannot have  `Constructors`
                                               |
  - Supports PARTIAL ABSTRACTION               |   - Supports full abstraction (By Design)
                                               |
  - Abstract methods can't be STATIC           |   - Abstract methods can't be STATIC 
                                               |
                                               |   - @Override annotation is not mandatory but highly recommended.
                                               |
                                               |   - Functional Interfaces support `Lambda`


‚ö†Ô∏è NOTES:
    - Abstract methods can not be static‚ùå
        -üí° Cause, Static methods belongs to the class/interface itself, 
        - & Abstract-methods must be overridden by sub-classes
        -üí°Static-Methods can't be over-ridden...

    - Default method in an Interface (Java 8+ | for backward compatibility with lambdas)
        - default is a keyword
        - used only in interface
        - Allows an interface to have a method with a body
        - Is implicitly public & non-static
        - Can be overridden by implementing classes
        - üí° Has nothing to do with "default" access-modifiers(Java 1.0)

    - Protected access-modifier is not allowed in an "interface"

_______________________________________________________________________________________







---------------------------------------------------------------------------------------
üí°: ‚≠ê TYPES OF INTERFACES ‚≠ê

‚≠ê 1. Normal Interface:
    - An interface with multiple abstract methods
    - Helpful when a class must implement more than 1 behaviour
    - Can't be implemented using lambda expressions


‚≠ê 2. Functional Interface:
    - An interface with exactly 1 Abstract Method
    - May contain:
        ‚Ä¢ default methods
        ‚Ä¢ static methods
        ‚Ä¢ private methods
    - Used in lambda expressions
    - Marked using @FunctionalInterface (optional but recommended)

    - Ex. Predicate<T>      | Function<T, R>      | Consumer<T>      | Supplier<T> 
          BiPredicate<T, U> | BiFunction<T, U, V> | UnaryOperator<T>
          BinaryOperator<T> | Runnable etc..
    ```Java
    @FunctionalInterface
    interface Calculator{int add(int a, int b);}

    Calculator c = (a,b) -> a+b; // Lambda üòâ
    System.out.println(c.add(10,20));
    ```



‚≠ê 3. Marker Interface:
    - Contains NO methods
    - Used to mark a class
    - JVM or frameworks check for it's presence
    - Used for metadata

    - Ex. Serializable | Cloneable | RandomAccess
    ```Java
    interface Serializable{}
    ```

---------------------------------------------------------------------------------------



_______________________________________________________________________________________








_______________________________________________________________________________________

üí°: ‚≠ê POLYMORPHISM ‚≠ê

    - One interface / parent type, Multiple implementations
    - Ability of objects of different classes to be treated as instances of a common parent type.

    ‚úîÔ∏è Pros
        - Flexibility
        - Extensibility
        - Reduced coupling
        - Code reusability

    üê• Ex. Animal ‚Üí Dog / Elephant / Lion

    
   ‚úîÔ∏è ‚≠ê Types of Inheritance ‚≠ê
        
        - 1). Compile-Time Polymorphism (Static Polymorphism):

                - Achieved using ----------------> Method-OverLoading üöõ

                - Decision made at *compile-time*

                - Same method name, Different parameter list

                - ‚ö†Ô∏è Java doesn't support operator-overloading (except `+` for String concatenation)
                


        - 2). Run-Time Polymorphism (Dynamic Polymorphism):

                - Achieved using -----------------> Method-OverRiding üö¥‚Äç‚ôÄÔ∏è
                
                - Decision made at *runtime*

                - Requires Inheritance



_______________________________________________________________________________________


- **Static-Binding**                                  |  - **Dynamic-Binding**
                                                      |
  - Aka *early-binding* because method to be called   |    - The type of object is determined at runtime.
    is determined based on the reference-type not on  |      [Basically, Method Binding happens at run-time]
    the object-type.                                  |
                                                      |
  - Resolved at compile-time.                         |    - Resolved at run-time.
                                                      | 
  - Applies to *static, private & final methods*      |    - Applies to over-ridden methods
                                                      |    
  - Faster execution                                  |    - Slightly slower (runtime-lookup üëÄ)
                                                      |


    ‚ö†Ô∏è Notes:
        - Static-Methods can't be annotated with @Overridden.
  

    ‚≠ê  Parent p ================> new Child();
         *reference*              *object-type*


    ‚≠ê *UpCasting*:
            - [Implicit & Safe] 
            - We can only access the static-methods defined in super-class(Parent)
            - We can access the overridden-methods of child-class.


    ‚≠ê *DownCasting*: 
            - [Explicit & Risky] 
            - Explicitly converting *parent-reference* to *child-reference*
            - We can access the sub-class specific methods.
            - It must be done Explicitly.

_______________________________________________________________________________________








_______________________________________________________________________________________
üí°: ‚≠ê Revise ‚≠ê


## Revise the following files:
   - encapsulationEx.java
   - whatIsInheritence.java
   - InheritenceWizard.java
   - InheritenceEx.java
   - abstractEx.java
   - interfaceEx.java
   - interfaceLambdaEx.java

_______________________________________________________________________________________




--------------------------------------‚≠ê‚≠ê CHAPTER I ENDS ‚≠ê‚≠ê----------------------------------------

