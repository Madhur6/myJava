----------------------------------------â­â­ âœ¨ INDEX âœ¨ â­â­----------------------------------------

ğŸ’¡ CHAPTER I   : JAVA EVOLUTION TIMELINE (KEY VERSIONS) âœ”

ğŸ’¡ CHAPTER II  : JAVA BASICS (Source Code to Bytecode, JVM and Platform Independence) ğŸ’«

ğŸ’¡ CHAPTER III : Object-Oriented Programming (OOPsğŸ˜…) (Classes and Objects State and Behavior)

ğŸ’¡ CHAPTER IV  : Main Method ğŸ¦¸â€â™‚ï¸, Constructor, Variables & Operations etc...

ğŸ’¡ CHAPTER V   : Data Types ğŸ’ (Primitive vs. Object Reference Types & Examples and Characteristics)



----------------------------------------â­â­ âœ¨ INDEX âœ¨ â­â­----------------------------------------
				                      
									  << LET'S START LEARNING ğŸ˜Š >>


----------------------------------------â­â­ CHAPTER I â­â­----------------------------------------
#1 JAVA EVOLUTION TIMELINE (KEY VERSIONS) âœ”

	- Java 1.0 (1996)	-> Basic language, AWT, applets, core classes
	- Java 1.1 (1997)	-> Inner classes, JDBC, RMI
	- Java 1.2 (1998)	-> (J2SE) Collections Framework (Iterator), Swing, List / Set / Map 
	- Java 1.3 (2000)	-> Minor enhancements
	- Java 1.4 (2002)	-> assert, NIO, regex
	- Java 1.5 (2004)	-> (Java5) Generics, Enhanced for-loop, Annotations, Autoboxing
	- Java 6   (2006)	-> Performance & Library updates
	- Java 7   (2011)	-> Try-with-resources, multi-catch
	- Java 8   (2014)	-> Lambdas, Streams, Functional Interfaces, Optional class
	- Java 9   (2017)	-> Module system
	- Java10-17(2018-21)-> var, Records, Sealed classes
	- Java 21  (2023)	-> (LTS) Leveraging Virtual Threads (Project Loom), String templates
	- Java 25  (2025 ~)	-> More language & JVM enhancements

_______________________________________________________________________________________

ğŸ’¡: â­ Collection Framework â­
	- A Library ğŸ“–
	- Collections Framework [JCF], Replaced the older "Enumeration" interface.
	
_______________________________________________________________________________________

ğŸ’¡: Interfaces (Blueprints): 

	- Defines std. behaviours for different types of collections
		
		Interface	                Purpose

		- Iterable<E>	           -> Super-interface for `for-each` loop (Any class that implements `Iterable` can be used inside "for-each")
				                   -> Collection<E> extends `Iterable`

		- Collection<E>            -> Root interface for most collection types
				                   -> Adds basic operations: add() | remove() | size() | contains()

		- List<E>	               -> Ordered collection, Allows duplicates

		- Set <E> 	               -> No duplicates

		- SortedSet<E>	           -> Set with sorted order

		- NavigableSet<E>          -> Extends `SortedSet` with navigation

		- Queue<E>	               -> FiFo collections

		- Deque<E>	              <-> Double-ended queue

		- Map<K, V>	               -> Key-Value pairs (not part of Collection)

		- SortedMap<K,V>           -> Sorted keys in a map

		- NavigableMap<K,V>        -> Extended sorted map with navigation






```Examples ğŸ”¥

		Collection<Integer> c = new ArrayList<>();
		

		List<String> L = new ArrayList<>();
		
		
		Set<Integer> s = new HashSet<>();

		
		SortedSet<String> p = new TreeSet<>();

		
		NavigableSet<Integer> nav = new TreeSet<>(List.of(10,100,30,44,2,7));
		nav.lower(7) | nav.higher(10) | nav.ceiling(22) | nav.floor(11)
		

		Queue<Integer> q = new LinkedList<>();

		
		Deque<Integer> dq = new LinkedList<>();
		dq.removeIf(n -> n % 2 == 0);
		dq.removeIf(n -> n == 23);
		dq.removeIf(n -> n > 30 ? true : false); // same as this: n -> n > 30
		
		
		Map<Integer, Integer> m = new HashMap<>();


		SortedMap<Integer, Integer> sm = new TreeMap<>();

		
		NavigableMap<Integer, Integer> nm = new TreeMap<>();
		nm.ceilingKey(5) | nm.floorKey(46)

		
		Iterable<String> it = List.of("a", "b", "c");
		for (String x: it) {
			System.out.println(x);
		}
		
```âš ï¸




_______________________________________________________________________________________

ğŸ’¡: Concrete Classes (Implementations)
	
	- Actual working classes we use.

	â­ List Implementations
	  
		Class	            Feature

		- ArrayList      -> Fast, resizable array, good for indexing
		- LinkedList     -> Doubly Linked List, Good for insertion/removal
		- Vector 	     -> Legacy version of `ArrayList`, Synchronized
		- Stack 	     -> Legacy, extends `Vector`(LIFO)


	â­ Queue / Deque Implementations

		Class	            Feature

	    - PriorityQueue         -> Elements ordered by priority (min-heap)
        - ArrayDeque            -> Fast deque, stack & queue replacement
        - LinkedList            -> Implements List + Queue + Deque
        - PriorityBlockingQueue -> Thread-safe priority queue (concurrent)
        - DelayQueue            -> Holds elements until delay expires
        - ConcurrentLinkedQueue -> High-performance non-blocking queue


	â­ Set Implementations
	  
		Class	            Feature

		- HashSet        -> No duplicates, No ordering
		- LinkedHashSet  -> Maintains insertion order
		- TreeSet	     -> Sorted Set (Uses Red-Black Tree)


	â­ Map Implementations
	  
		Class	            Feature

		- HashMap         -> Key-value pairs, Fast access
		- LinkedHashMap   -> Maintains insertion order
		- TreeMap         -> Sorted Keys
		- HashTable 	  -> Legacy, synchronized
		- Properties	  -> Used for config files, extends `HashTable`
		- WeakHashMap	  -> Keys eligible for GC when no strong ref.
		- ConcurrentHashMap> Thread-safe map (JAVA 5+)


ğŸ’¡: JCF Hierarchy:
	ITERABLE 
	    ^
	    |
	 COLLECTION
	 /   |     \
    LIST  SET   QUEUE                      âœ¨sub-interfacesâœ¨
  /        |       \
ARRAYLIST  HASHSET  PRIORITY-QUEUE         âœ¨Implementationâœ¨
LINKEDLIST TREESET  ARRAY-DEQUE



ğŸ’¡:	MAP (separate branch)
	 ^
	 |
	HASH-MAP, TREE-MAP, LINKED-HASH-MAP



ğŸ’¡: Check this out ğŸ˜
	
	Component		Examples			                purpose
	
	Interfaces 		List/Set/Map/queue... 		        Define std behaviours

	Classes			ArrayList/HashMap/TreeSet...	    Actual data structures

	Utilities		Collections/Arrays/Comparator       Sorting, searching...
				    /Enumeration/Iterator/Objects
				    /ListIterator/AbstractCollection
				    /AbstractList...

	Legacy classes		Vector/HashTable/Stack		    For backward compatibility
	
	Traversal Tools		Iterator/ListIterator/		    Iterate over collections
				        /Enumeration		




_______________________________________________________________________________________
	
	
ğŸ’¡:
```
public class EnumerationEx {
	public static void main(String[] args) {
		Vector<String> vec = new Vector<>();
		vec.add("harry");
		vec.add("ron");
		vec.add("hermionne");
		
		Enumeration<String> e = vec.elements();
		while (e.hasMoreElements()) {
			String name = e.nextElement()
			System.out.println(name);}}}
- But Enumeration was:
	- Read-only
	- Lacking the "remove()" method ğŸ˜’

- âœ¨ Then came "Iterator"ğŸ˜®

Iterator<String> it = list.iterator();
while (it.hasNext()){
	String item = it.next();
	if (item.equals("foo")) it.remove(); // SafeğŸ˜‰ âœ”
}
```


```DelayQueueâ­
class DelayItem implements Delayed {
	private int x;
	private long expiry;
	
	public DelayItem(int x, long e) {
		this.x = x;
		this.expiry = System.currentTimeMillis() + e;}
	
	@Override
	public int compareTo(Delayed o) {
		return Long.compare(this.getDelay(TimeUnit.MILLISECONDS), o.getDelay(TimeUnit.MILLISECONDS));}

	@Override
	public long getDelay(TimeUnit unit) {
		long diff = expiry - System.currentTimeMillis();
		return unit.convert(diff, TimeUnit.MILLISECONDS);}}

public class introduction {
	public static void main(String[] args) throws InterruptedException {
		DelayQueue<DelayItem> d = new DelayQueue<>();
		d.add(new DelayItem(1, 10000));
		d.add(new DelayItem(3, 5000));
		System.out.println(d.take()); // takes 10 secs. to print '1'}}
```âš ï¸

_______________________________________________________________________________________


--------------------------------------â­â­ CHAPTER I ENDS â­â­----------------------------------------






----------------------------------------â­â­ CHAPTER II â­â­----------------------------------------
#2 JAVA BASICS (Source Code to Bytecode, JVM and Platform Independence) ğŸ’«


_______________________________________________________________________________________
ğŸ’¡: â­ FLOW â­


   src(.java)
	|
	|
    |  javac
	|
	v
   bytecode(.class)      <-platform-independent
	|
	|		   JVM
	|		   |_class loader
	|		   |_Bytecode Verifier
	|		   |_Execution Engine (Interpreter | JIT compiler [for hot codeğŸ”¥])
	|
	v
   Native-machine-code   <-JVM itself is platform-dependent


â­ Java source code (.java) is compiled by javac into `bytecode`
â­ JVM loads, verifies & executes "byte-code"
â­ Initially, byte-code is interpreted & JIT(just-in-time compiler) compiles frequently-executed-code(hot-codeğŸ”¥) into `native-machine-code`
â­ Platform-Independence [Any machine that has 'jvm' can execute the .class file]
â­ Interpretor is inside the JVM (Not a separate program)



ğŸ’¡: ğŸ”¥ HOT-CODE ğŸ”¥

- Hot-Code is frequently executed code like "methods or loops" that run multiple times.
- Code-paths that JVM detects as performance-criticalâš ï¸.

```
while(true){
     someMethod(); // very hotğŸ”¥
}
```
â­ JVM interprets byte-code first, Counts executions(method call / loop back-edges)
â­ Marks code as "hotğŸ”¥" when thresholds are crossed
â­ Sends it to JIT compiler, JIT compiles it into native-machine-code
â­ After which, JVM skips `interpretation` -> Native-code runs much faster
â” Why not just "JIT" everything?
	- Because, It is expensive
	- Many methods run only once
	- Compiling "cold-codeâ„ï¸" would waste c.p.u. & memory


_______________________________________________________________________________________



--------------------------------------â­â­ CHAPTER II ENDS â­â­----------------------------------------







----------------------------------------â­â­ CHAPTER III â­â­-------------------------------------------
#3 Object-Oriented Programming (OOPsğŸ˜…) (Classes and Objects State and Behavior)

_______________________________________________________________________________________
ğŸ’¡: â­ Java Oops â­


- Style of programming, Where we organize our programs around objects that encapsulate both data(state) & logic(behaviour). ğŸ’¡

	**Class**  - Blueprint that outlines the structure of our program.

	**Object** - Programming representation of real-world entity. (OR Run-time instance of a class representing a real-world-entity)

- JVM creates objects, With the help of Class, Hence called 'blueprint'.


â­ JVM ----------------------> Objects ----------------------> Class (BlueprintğŸ“°)
             creates                        with the help of
                                                  ^
					 	                          |
                                                  | state & behaviour information
                                                  |
                                                  |
                                                Programmer(US)  
                                            
- Programmer, Requests object-creation using "new" keyword
	- JVM allocates the memory & creates the object at run-time.
	
- In OOPs design, Programmer describes an object using 2 main aspects:
   	- **State**    : Represents it's properties, The 'attributes' possibly distinguishing 1 object from the other.
   	- **Behaviour**: Represents the actions Object might perform.

- *Note*: 
	- In OOPs design usually, An object is described by it's state & behaviour, State is represented by instance variable.
	- Behaviours are represented via non-static methods. [Are typically modeled with instance-methods (non-static)]
 
_______________________________________________________________________________________



--------------------------------------â­â­ CHAPTER III ENDS â­â­-------------------------------------







----------------------------------------â­â­ CHAPTER IV â­â­----------------------------------------
#4 â­ Main Method ğŸ¦¸â€â™‚ï¸, Constructor, Variables & Operations etc...â­



_______________________________________________________________________________________
ğŸ’¡: â­ ENTRY POINT â­


## public static void main(String[] args){}:

   - main method   : [Entry-point of our program]

   - String[]      : To accept the `cli` arguments. (command line interface)

   - args          : Accessible as array of string. [can be hello/apple/args/etc]

   - Can also write: (String...args) [Allows method to accept 0 or more arguments.] â­

_______________________________________________________________________________________



_______________________________________________________________________________________
ğŸ’¡: â­ Constructor â­

```Java
class Student {
	String name;
	int age;

	// â­ If no constructor is defined by the programmer,
	//    Java automatically provides a DEFAULT constructor
	//    - Student(){}


	// Explicit No-Argument Constructor
	Student(){
		// Initializes object with default values
	}


	// Parameterized Constructor
	Student(String inputName, int inputAge){
		this.name = inputName;
		this.age = inputAge;
	}

	
	// Copy Constructor (User-Defined)
	// Java doesn't provide a built-in copy constructor
	// We must define it manually

	Student(Student s){
		this.name = s.name;
		this.age = s.age;
	}
}
```
_______________________________________________________________________________________




_______________________________________________________________________________________
ğŸ’¡: â­ Constructor â­


```Java
class Student {
	String name;
	int age;

	// â­ If no constructor is defined by the programmer,
	//    Java automatically provides a DEFAULT constructor
	//    - Student(){}


	// Explicit No-Argument Constructor
	Student(){
		// Initializes object with default values
	}


	// Parameterized Constructor
	Student(String inputName, int inputAge){
		this.name = inputName;
		this.age = inputAge;
	}

	
	// Copy Constructor (User-Defined)
	// Java doesn't provide a built-in copy constructor
	// We must define it manually

	Student(Student s){
		this.name = s.name;
		this.age = s.age;
	}
}
```


âš ï¸ Notes:
- Constructor name must be same as class-name
- Constructor don't have a return type
- Constructors are called automatically during object creation
- Constructors can be overloaded
- If any constructor is defined, Java won't create a default one
- Copy constructor creates a new object with copied values


```Java
// Inside the main methodğŸ‘€
Student s1 = new Student("Harry", 12);

Student s2 = new Student(s1); // copy constructor

```
_______________________________________________________________________________________





_______________________________________________________________________________________
ğŸ’¡: â­ Variables â­

â­ A variable is a name given to a memory location that stores some data.
â­ Used to store data & retrieve data during program execution
â­ The value stored in a variable can change, Hence the term "variable"

â­ Naming Rules & Conventions:
	- Java is case-sensitive
	- Must start with:
		- A letter (a-z, A-Z) or underscore (_)

	- Can not start with a digit
	- Follow camelCase convention
	- Must NOT use reserved keywords (int, new, class etc)


â­ Var keyword (Type Interface):
	- Introduced in Java 10
	- Type is inferred at compile-time
	- Once inferred, The type can't change

	âš ï¸ Var can only be used for local-variables, Not instance or static variables.

	```Java
		var num = 42;  // Compiler infers type as int
		num = "hello"; // âŒ Not allowed  
	```

â­ Types of Variables:

	- Static Variables:
		- Class-Level âœ”ï¸
		- Belong to the class, Not to any object
		- Shared across all instances
		- Declared using `static` keyword
	
	- Instance Variables:
		- Object-Level âœ”ï¸
		- Declared inside a class but outside methods
		- Each object has its own copy

	- Final Variables:
		- Value can't be modified once initialized
		- Used to create constants

_______________________________________________________________________________________







_______________________________________________________________________________________
ğŸ’¡: â­ Operations â­

â­ Increment Operators
```Java
int x = 5, y = 10;

int res = x++ + ++x;
// x++ â†’ uses 5, Then x becomes 6
// ++x â†’ Increments x to 7, Then uses 7
// Result: 5 + 7 = 12


int res1 = ++y + y++;
// ++y â†’ increments y to 6, Then uses 6
// y++ â†’ uses 6, then increments y to 7
// Result: 6 + 6 = 12

// Same logic applies to decrement operators (--x, x--)

```
_______________________________________________________________________________________






_______________________________________________________________________________________
ğŸ’¡: â­ Packages â­

â­ Packages in Java:
	- A pkg is a namespace that groups related classes, interfaces & sub-packages
	- Used to organize code, avoid name conflicts, & improve maintainability


â­ Types of Pkgs:

	- Built-In Pkgs
		- Provided by Java
		- Ex. java.util, java.lang(automatically imported), java.io, java.time

	- User-Defined Pkgs:
		- Created by developers to organize application code


â­ Steps to create a PKG:
	- 1. create a folder -> ur_pkg_name/
	```Java
	package ur_pkg_name;

	public class FileName{
		public static void main(String[] args){
			System.out.println("Hello, Pkg!");
		}
	}
	```

	- 2. Compile the code:
		- javac ur_pkg_name/FileName.java

	- 3. Run the program:
		- java ur_pkg_name.FileName

	âš ï¸ Note:
		- A class outside a PKG can't access a default-access class from another pkg.
		- Always use a public-class with main() when accessing from outside the pkg.
		- If files are in the current working directory, No extra configuration is needed
		- Otherwise, Configue CLASSPATH:
			- Temporary(cmd line):
				- set CLASSPATH=pkg_path;main_class_path 
		
			- Permanent:
				- Set env-var. CLASSPATH in system settings

_______________________________________________________________________________________





_______________________________________________________________________________________
ğŸ’¡: â­ Access Modifiers â­

â­ Types of Access Modifiers

- Types:

--------------------------------------------------------------------------------------------------------------------

modifiers   - Same-Class      | - Same Package      | - Same Pkg          | - Diff. Pkg       | - Diff. Pkg 
                              |   & Sub-class       |   & non-subclass    |  & Sub-Class      | & non-sub-class
--------------------------------------------------------------------------------------------------------------------
private         yes                  no                    no                   no                   no

default         yes                  yes                   yes                  no                   no

protected       yes                  yes                   yes                  yes                  no

public          yes                  yes                   yes                  yes                  yes

--------------------------------------------------------------------------------------------------------------------

âš ï¸ Important notes:
	- Java supports 4 access-modifiers
	- OverRiding Rule:
		- An overridden method can increase visibility but cannot reduce it.
		- protected  â†’  public
		- public     â†’  protected/private
	
	- Methods that CAN'T be overridden:
		- final methods
		- static methods
		- private methods

_______________________________________________________________________________________




_______________________________________________________________________________________
ğŸ’¡: â­ Revise â­


## Revise the following files:
   - compileEx.java
   - cliEx.java
   - macEx.java
   - scopeEx.java
   - consumeBuffer.java
   - stringArgs.java
   - incrementEx.java
   - whatIsClass.java
   - whatIsMethod.java
   - whatIsOops.java
   - staticVar.java
   - staticMethod.java
   - accessModifiers.java

_______________________________________________________________________________________



----------------------------------------â­â­ CHAPTER IV ENDS â­â­-------------------------------------



----------------------------------------â­â­ CHAPTER V â­â­----------------------------------------
#5 â­ Data Types ğŸ’ (Primitive vs. Object Reference Types & Examples and Characteristics) â­


â­ Primitive : Holds fundamental values(Simple Bit patterns)
â­ Object Ref: Holds, Well, References to objects, Like a "pointer" ğŸ‘‰
               - All references for a "given JVM" will be same size regardless of objects they reference.
	       - Once object is not being referred, It is eligible for "GC" (Garbage Collectible Heap)
	       - Once object is set to null(deprogrammed), It means that now nobody can get to that object we had been referring to...
	       
_______________________________________________________________________________________
ğŸ’¡: â­ Data - Types in JAVA â­


		--- Primitive Types ---

ğŸ¥byte          // Integer          (1 byte)  | Range: -128 to 127
ğŸ¥short         // Integer          (2 bytes) | Range: -32,768 to 32,767
ğŸ¥int           // Integer          (4 bytes) | Range: -2^31 to 2^31-1
ğŸ¥long          // Integer          (8 bytes) | Range: -2^63 to 2^63-1 | e.g., 123L
ğŸ¥float         // Single-precision (4 bytes) | Range: varies          | e.g., 3.14f
ğŸ¥double        // Double-precision (8 bytes) | Range: varies          | e.g., 3.14159265358979
ğŸ¥boolean       // true or false    (size: JVM dependentğŸ˜‰)
ğŸ¥char          // Single character (2 bytes) | Range: 0 to 65535 | Unicode values




		--- Object Reference Types (Non-Primitive) ---

- Store references (memory addresses) to objects.

- Common reference types:

ğŸ¥String         // Immutable sequence of chars. | Ex., "Hello, Java!"
ğŸ¥int[]          // Array of primitive integers
ğŸ¥String[]       // Array of String references 

âš ï¸ Arrays are objects, Hence reference-types


- Classes:
ğŸ¥ArrayList     // Dynamic array        | java.util.ArrayList
ğŸ¥LinkedList    // Doubly linked-list   | java.util.LinkedList
ğŸ¥HashMap       // Key-value pairs      | java.util.HashMap
ğŸ¥HashSet       // Unique collection    | java.util.HashSet

âš ï¸ Java has no built-in-pair or "Tuple" data-type
âš ï¸ "Pair" from javafx.util.Pair is not part of core-java


- Interfaces (Blueprints):
ğŸ¥List       // Ordered Collection
ğŸ¥Set        // No duplicates
ğŸ¥Map        // Key-value mapping (not a part of collection)

âš ï¸ Collections (List, Set, Map) are interfaces, not data-types themselves


- Other Reference Types:
ğŸ¥Enum       // Fixed set of constants
ğŸ¥Record     // Immutable data carrier (Java 14+)
ğŸ¥Class      // User-defined or built-in classes


âš ï¸ Java has 8 primitive data-types.
âš ï¸ All other data in Java is handled using reference types, Which include classes, interfaces, arrays, enums, & records.


_______________________________________________________________________________________




_______________________________________________________________________________________
ğŸ’¡: â­ DIFFERENCES â­


- **Primitive-Data-Type**                                      | - **Non-Primitive-Data-Type**
                                                               |
  - Are NOT objects                                            |   - Are Objects.
                                                               |
  - Are passed by values                                       |   - Reference value is passed by value
                                                               |
  - Basic data-types [Pre-defined].                            |   - Reference-Type (Classes, Interfaces, Arrays).
                                                               |
  - Value types (Immutability concept doesn't apply)           |   - Immutable/ Mutable.
                                                               |
  - Non-Nullable.                                              |   - Nullable.
                                                               |
  - Hold data(actual values) directly in memory                |   - Stores reference to objects.
                                                               |
  - Stored in stack.(local variables)                          |   - Objects stored on Heap 
                                                               |
  - Instance variables live inside objects on heap             |   - References stored in stack (If local)
                                                               |
  - Doesn't have methods.                                      |   - Have methods.
                                                               |
  - Ex. byte, short, int, long,                                |   - Ex. ğŸŒ ArrayList                                         [Mutable],
                                                               |         ğŸŒ Array[int/String]                 
        float, double, char, boolean                           |         ğŸŒ String,**Wrapper-Classes**  [Immutable].
                                                               |         ğŸŒ Custom-Classes, Objects                           [Mutable but can be made immutable]


âš ï¸ Note: String is an Immutable object.
âš ï¸       Java is strictly pass-by-value (Even for object references)


// Q1:  Why does immutability not apply to primitive types?
// Ans: Primitive types represent raw values stored directly in memory, are Not objectsâŒ.
//      They have no identity or internal state.
//      Reassigning a primitive replaces the stored value in the variable.
//      There is no original object whose state is preserved.



ğŸ Example 1: Primitive Type-----------------------------------------------------------------------------------------------

   - int a = 10;  // The value 10 is directly stored in the memory allocated for 'a'.
   - a = 20;      // A new value (20) is stored, replacing the previous value.




ğŸ Example 2: String (Immutable Object)------------------------------------------------------------------------------------

   - String s = "hello";    // Let 's' be stored at memory address 'abcX123'.
   - s += " world";         // Concatenation creates a new String at a different address, e.g., 'xyzY456'.

   - System.out.println(s); // Prints "hello world".
                            // The original memory location ('abcX123') remains unchanged.
_______________________________________________________________________________________









_______________________________________________________________________________________
ğŸ’¡: â­ Revise â­


## Revise the following file:
   - primitiveAndNonPrimitive.java

_______________________________________________________________________________________





----------------------------------------â­â­ CHAPTER V ENDS â­â­----------------------------------------











