----------------------------------------------------------------------------‚≠ê‚≠ê ‚ú® INDEX ‚ú® ‚≠ê‚≠ê------------------------------------------------------------------------------

üí° CHAPTER I   : JAVA EVOLUTION TIMELINE (KEY VERSIONS) ‚úî

üí° CHAPTER II  : JAVA BASICS (Source Code to Bytecode, JVM and Platform Independence) üí´

üí° CHAPTER III : Object-Oriented Programming (OOPsüòÖ) (Classes and Objects State and Behavior)

üí° CHAPTER IV  : Main Method ü¶∏‚Äç‚ôÇÔ∏è

üí° CHAPTER V   : Data Types üêí (Primitive vs. Reference Types & Examples and Characteristics)



----------------------------------------------------------------------------‚≠ê‚≠ê ‚ú® INDEX ‚ú® ‚≠ê‚≠ê------------------------------------------------------------------------------
									<< LET'S START LEARNING üòä >>


------------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER I ‚≠ê‚≠ê-----------------------------------------------------------------------------
#1 JAVA EVOLUTION TIMELINE (KEY VERSIONS) ‚úî

	- Java 1.0 (1996)	-> Basic language, AWT, applets, core classes
	- Java 1.1 (1997)	-> Inner classes, JDBC, RMI
	- Java 1.2 (1998)	-> (J2SE) Collections Framework (Iterator), Swing, List / Set / Map 
	- Java 1.3 (2000)	-> Minor enhancements
	- Java 1.4 (2002)	-> assert, NIO, regex
	- Java 1.5 (2004)	-> (Java5) Generics, Enhanced for-loop, Annotations, Autoboxing
	- Java 6   (2006)	-> Performance & Library updates
	- Java 7   (2011)	-> Try-with-resources, multi-catch
	- Java 8   (2014)	-> Lambdas, Streams, Functional Interfaces, Optional class
	- Java 9   (2017)	-> Module system
	- Java10-17(2018-21)	-> var, Records, Sealed classes
	- Java 21  (2023)	-> (LTS) Leveraging Virtual Threads (Project Loom), String templates
	- Java 25  (2025 ~)	-> More language & JVM enhancements
_______________________________________________________________________________________
üí°: ‚≠ê Collection Framework ‚≠ê
	- A Library üìñ
	- Collections Framework [JCF], Replaced the older "Enumeration" interface.
	
_______________________________________________________________________________________
üí°: Interfaces (Blueprints): 

	- Defines std. behaviours for different types of collections
		
		Interace	    Purpose

		- Collection<E>  -> Root interface for most collection types
		- List<E>	 -> Ordered collection, Allows duplicates
		- Set <E> 	 -> No duplicates
		- SortedSet<E>	 -> Set with sorted order
		- NavigableSet<E>-> Extends `SortedSet` with navigation
		- Queue<E>	 -> FiFo collections
		- Deque<E>	<-> Double-ended queue
		- Map<K, V>	 -> Key-Value pairs (not part of Collection)
		- SortedMap<K,V> -> Sorted keys in a map
		- NavigableMap<K,V> Extended sorted map with navigation
		- Iterable<E>	 -> Super-interface for `for-each` loop
_______________________________________________________________________________________

üí°: Concrete Classes (Implementations)
	
	- Actual working classes we use.

	‚≠ê List Implementations
	  
		Class	            Feature

		- ArrayList      -> Fast, resizable array, good for indexing
		- LinkedList     -> Doubly Linked List, Good for insertion/removal
		- Vector 	 -> Legacy version of `ArrayList`, Synchronized
		- Stack 	 -> Legacy, extends `Vector`(LIFO)


	‚≠ê Set Implementations
	  
		Class	            Feature

		- HashSet        -> No duplicates, No ordering
		- LinkedHashSet  -> Maintains insertion order
		- TreeSet	 -> Sorted Set (Uses Red-Black Tree)


	‚≠ê Map Implementations
	  
		Class	            Feature

		- HashMap        -> Key-value pairs, Fast access
		- LinkedHashMap  -> Maintains insertion order
		- TreeMap        -> Sorted Keys
		- HashTable 	 -> Legacy, synchronized
		- Properties	 -> Used for config files, extends `HashTable`
		- WeakHashMap	 -> Keys eligible for GC when no strong ref.
		- ConcurrentHashMap Thread-safe map (JAVA 5+)

üí°: JFC Hierarchy:
	ITERABLE 
	    ^
	    |
	COLLECTION
	/   |     \
 ARRAYLIST HASHSET PRIORITY-QUEUE
 LINKEDLIST TREESET ARRAY-DEQUE

	MAP (separate branch)
	 ^
	 |
	HASH-MAP, TREE-MAP, LINKED-HASH-MAP



üí°: Check this out üòÅ
	
	Component		Examples			purpose
	
	Interfaces 		List/Set/Map/queue... 		Define std behaviours

	Classes			ArrayList/HashMap/TreeSet...	Actual data structures

	Utilities		Collections/Arrays/Comparator   Sorting, searching...
				/Enumeration/Iterator/Objects
				/ListIterator/AbstractCollection
				/AbstractList...

	Legacy classes		Vector/HashTable/Stack		For backward compatibility
	
	Traversal Tools		Iterator/ListIterator/		Iterate over collections
				/Enumeration		




_______________________________________________________________________________________
	
	
üí°:
```
public class EnumerationEx {
	public static void main(String[] args) {
		Vector<String> vec = new Vector<>();
		vec.add("harry");
		vec.add("ron");
		vec.add("hermionne");
		
		Enumeration<String> e = vec.elements();
		while (e.hasMoreElements()) {
			String name = e.nextElement()
			System.out.println(name);}}}
- But Enumeration was:
	- Read-only
	- Lacking the "remove()" method üòí

- ‚ú® Then came "Iterator"üòÆ

Iterator<String> it = list.iterator();
while (it.hasNext()){
	String item = it.next();
	if (item.equals("foo")) it.remove(); // Safeüòâ ‚úî
}
```
_______________________________________________________________________________________


---------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER I ENDS ‚≠ê‚≠ê--------------------------------------------------------------------------






-----------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER II ‚≠ê‚≠ê----------------------------------------------------------------------------
#2 JAVA BASICS (Source Code to Bytecode, JVM and Platform Independence) üí´



_______________________________________________________________________________________
üí°: ‚≠ê FLOW ‚≠ê


src(.java) -------> byteCode(.class) ------------------jvm loads "byte-code" & "template/byte-code-interpretor" interpretss the byte-code(.class) & JIT(just-in-time compiles frequently executed byte-code directly into --> )---------------------->(native-machine-code) ‚úî
           javac                                  
                                                                               (Platform-Independence) [Any machine that has 'jvm' can execute the .class file]

‚≠ê Interpretor is inside the JVM (Not a separate program)


_______________________________________________________________________________________



---------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER II ENDS ‚≠ê‚≠ê-------------------------------------------------------------------------







----------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER III ‚≠ê‚≠ê----------------------------------------------------------------------------
#3 Object-Oriented Programming (OOPsüòÖ) (Classes and Objects State and Behavior)

_______________________________________________________________________________________
üí°: ‚≠ê Java Oops ‚≠ê


- Style of programming, Where we organize our programs around data rather than logic & objects rather than actions. üí°

**Class**  - Blueprint that outlines the structure of our program.

**Object** - Programming representation of real-world entity.

- JVM creates objects, With the help of Class, Hence called 'blueprint'.

                                            
‚≠ê Class(Blueprint) -------------------------> JVM ----------------------> Objects
                  with the help of class    |          creates
                                            |
                                            | state & behaviour information
                                            |
                                            |
                                        Programmer(US)  


- Now Programmer needs to provide more information, JVM is concerned about just 2 information about any object:
   - **State**: Represents it's properties, The 'attributes' possibly distinguishing 1 object from the other.
   - **Behaviour**: Represents the actions Object might perform.

- *Note*: In OOPs design usually, Behaviours are represented via non-static methods. [Are typically modeled with instance-methods (non-static)]

_______________________________________________________________________________________



--------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER III ENDS ‚≠ê‚≠ê-------------------------------------------------------------------------







-----------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER IV ‚≠ê‚≠ê----------------------------------------------------------------------------
#4 ‚≠ê Main Method ü¶∏‚Äç‚ôÇÔ∏è ‚≠ê



_______________________________________________________________________________________
üí°: ‚≠ê ENTRY POINT ‚≠ê


## public static void main(String[] args){}:

   - main method   : [Entry-point of our program]

   - String[]      : To accept the `cli` arguments. (command line interface)

   - args          : Accessible as array of string. [can be hello/apple/args/etc]

   - Can also write: (String...args) [Allows method to accept 0 or more arguments.] ‚≠ê


_______________________________________________________________________________________



---------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER IV ENDS ‚≠ê‚≠ê-------------------------------------------------------------------------






-----------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER V ‚≠ê‚≠ê-----------------------------------------------------------------------------
#5 ‚≠ê Data Types üêí (Primitive vs. Reference Types & Examples and Characteristics) ‚≠ê



_______________________________________________________________________________________
üí°: ‚≠ê Data - Types in JAVA ‚≠ê


// --- Primitive Types ---

boolean       // true or false
float         // Single-precision (4 bytes) | e.g., 3.14f
double        // Double-precision (8 bytes) | e.g., 3.14159265358979
byte          // Integer (1 byte) | Range: -128 to 127
short         // Integer (2 bytes) | Range: -32,768 to 32,767
int           // Integer (4 bytes) | Range: -2^31 to 2^31-1
long          // Integer (8 bytes) | Range: -2^63 to 2^63-1 | e.g., 123L
char          // Single character (2 bytes) | Unicode values



// --- Reference Types (Non-Primitive) ---

String        // Ex., "Hello, Java!"
int[]         // Array of integers
ArrayList     // Dynamic array | java.util.ArrayList
LinkedList    // Dynamic list | java.util.LinkedList
Map           // Key-value pairs | java.util.HashMap
Set           // Unique collection | java.util.HashSet
Pair          // Tuple-like structure | javafx.util.Pair (JDK with JavaFX)


_______________________________________________________________________________________



_______________________________________________________________________________________
üí°: ‚≠ê DIFFERENCES ‚≠ê


- **Primitive-Data-Type**                                      | - **Non-Primitive-Data-Type**
  - Are passed by values                                       |   - Are passed by reference
  - Basic data-types [Pre-defined].                            |   - Reference-Type.
  - Are not objects.                                           |   - Are Objects.
  - Immutable.                                                 |   - Immutable/ Mutable.
  - Non-Nullable.                                              |   - Nullable.
  - Hold data directly in memory.                              |   - Stores reference to objects.
  - Stored in stack.(local variables)                          |   - Stored in Heap [Reference stored in stack].
  - Instance variables live "inside objects on heap"           |
  - Doesn't have methods.                                      |   - Have methods.
                                                               |
  - Ex. byte, short, int, long, float, double, char, boolean...|   - Ex. ArrayList                                         [Mutable],
                                                               |   -     Arrays[String & int], String,**Wrapper-Classes**  [Immutable].
                                                               |   -     Custom-Classes, Objects                           [Mutable but can be made imutable]


‚≠ê Note: String is an immutable object.

// Q1: Why are primitive types immutable?
// Ans: Primitive types represent raw values stored directly in memory and are not tied to objects or references.
//      When you modify a primitive, a completely new value is created or assigned in memory.


// Example 1: Primitive Type-----------------------------------------------------------------------------------------------

   int a = 10;  // The value 10 is directly stored in the memory allocated for 'a'.
   a = 20;      // A new value (20) is stored, replacing the previous value.


// Example 2: String (Immutable Object)------------------------------------------------------------------------------------

   String s = "hello"; // Let 's' be stored at memory address 'abcX123'.
   s += " world";      // Concatenation creates a new String at a different address, e.g., 'xyzY456'.

   System.out.println(s); // Prints "hello world".
   // The original memory location ('abcX123') remains unchanged.
_______________________________________________________________________________________



---------------------------------------------------------------------------‚≠ê‚≠ê CHAPTER V ENDS ‚≠ê‚≠ê--------------------------------------------------------------------------











